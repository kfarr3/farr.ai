Title: Introductions
Date: 2016-08-27 21:47
Author: i6hb4k
Category: Uncategorized
Slug: 162
Status: draft

I am an experienced software engineer.  I've partnered with other skilled programmers who have an established consulting company and with the assistance of many others stay busy 40 hours a week writing code and solving other people's problems for money.  I've been doing this since 2006 when I graduated with a Bachelor's of Science in Computer Science with minors in Mathematics and Physics.  I'm not one of those programmers who started in college though, for me it's always been a passion.  I recall my pre-teen days of wanting to be an engineer and my dismay at the train set my grandmother bought me.  I've always tinkered, loved legos and building contraptions.  In middle school I discovered an affinity for computers.  I would pick up [Smart Computing](https://en.wikipedia.org/wiki/SmartComputing) and marvel at my ability to change the screen saver or customize windows 3.11.  Once that trill expired my interests turned to the terminal command prompt.  I started becoming interested in programming, using the help menu from [Quick Basic](https://en.wikipedia.org/wiki/QBasic) and manually typing code from magazines to see what it would do.  Over the years I would teach myself Visual Basic and learn how to make rudimentary Windows Form Applications.

I eventually started college and really learned the foundations of programming.  My drive and desire to learn was still high and for all of my Computer Science courses I was always ahead of the lecture and spent hours helping other students.  My first programming course used the [Dietel & Dietel C++ Book](http://www.deitel.com/) which I still have to this day.  It all came naturally to me, pointers, linked-lists, infinite-integer, etc.  My other courses suffered greatly though because I was only focused on learning what I wanted to learn.

I started college with the goal of being an application's programmer, I wanted to do GUI front ends.  All of the programming we did were console applications, so I saw non-gui applications as academic, non-professional.  In my mind, professional developers created applications with a GUI front-end and that's what I wanted to do.  I started learning Microsoft Foundations Classes, which aside form Visual Basic, was the only way to do Windows based front-ends at the time.  I didn't get too far into that when I discovered microcontroller programming.  Unfortunately I discovered embedded systems a ways after I barley passed my course in assembly programming.  I had access to the internet, it wasn't cheap but I had DSL and Web 1.0 days were loaded with great content to learn.  There was no social media to provide a distraction.  My very first microcontroller was an overpriced [Basic Stamp](https://www.parallax.com/product/bs2p24).  It had been years since QBasic, but the PBasic was still simple enough to understand.  I tinkered with this for a bit, turning LEDs on and off but I soon realized it's limited potential and moved onto [Microchip PIC microcontrollers](http://www.microchip.com/design-centers/microcontrollers).

I don't remember which part I started out with, but it was a tiny, cheap DIP packaged 8-bit microcontroller.  The biggest learning curve here was figuring out how to compile and flash the part.  Luckily, I started after the days of [UV Erased EEPROMS](https://en.wikipedia.org/wiki/EPROM) and utilizing high voltage could erase and reprogram my PIC Microcontroller.  I still could not afford the C compiler, so I resorted to learning PIC Assembly and using the free assembler to create my binary.  I built my own High Voltage programmer using the parallel port, something similar to [this one](http://www.best-microcontroller-projects.com/pic-programmer-circuit.html).  There was no confirmation that it worked, there was no warm and fuzzy feelings, either the LED blinked or it didn't.  The most basic of Hello World applications for an embedded system, just flash the LED.  Now PICs have a lot of different configuration items, you have fuses, TRIS registers to set input/output state, internal pull-up/down resisters, clock settings (internal [resister/capacitor oscillators](https://en.wikipedia.org/wiki/RC_oscillator) did make it nice though), and then actually getting your timing correct and writing the output register.  Between making sure that the assembly code was correct and the file was actually programmed into the part, I'm still amazed that I ever got it to work without any assistance.  Fast-forwards a few months and I had built up on a breadboard a key-less entry and remote start system for my car.  I used an off-the-shelf keyfob with rolling code [KeeLoq](http://www.microchip.com/design-centers/embedded-security/reference-designs/keeloq) for my transmitter.  It all worked great and was what got me into embedded programming.

I spent quite a few years working on ARM7 and embedded x86 projects.  Network controlled audio amplifiers, monitor and control equipment, elevator control systems, automated book binders, etc.  So many very fun and interesting projects.  I learned the hard way about embedded design patterns, we didn't have any design pattern courses in college and it never came up.  During this time I was (and still am) an avid fan of [Joel Spolsky](http://www.joelonsoftware.com/) and learned a lot from reading his blog.  I started working my way up the development stack since I was doing so much embedded networking, I found myself working on devices with embedded websevers running web pages to communicate with the devices.  This was mostly pre-AJAX days, you used an iframe and refreshed HTML in it, grabbing the JavaScript objects and manually repopulating the DOM.  Don't worry if any of that doesn't make any sense, it's my version of walking to school in the snow barefoot uphill both ways.

I got into Mobile development around the iPad 2 days, focusing mostly on iOS development.  Professionally I did a handful of apps, a dental patient portal, food warehouse climate control monitor/control (always with the monitor and control), a bluetooth app to connect to custom hardware to, ahem, monitor and control it, and even a social networking site.  As of late I'm focusing more on Xamarin to increase development efficiency.  Xamarin lets you develop for both Android and iOS at the same time, often utilizing the same code base, but it still lets you compile down to native applications and maintain a native interface.  For the majority of the applications I work on, a native interface is very important.  For games, not so much, but for utility apps it's a requirement.

As of late I've become increasingly interested in Value Investing and planning for my future.  I follow Warren Buffett, and ....
